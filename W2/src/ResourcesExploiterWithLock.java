import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Lớp ResourcesExploiterWithLock kế thừa từ ResourcesExploiter
 * Sử dụng ReentrantLock để đồng bộ hóa thay vì synchronized
 */
public class ResourcesExploiterWithLock extends ResourcesExploiter {
    // Biến lock để đồng bộ hóa truy cập
    private ReentrantLock lock;
    
    /**
     * Phương thức khởi tạo
     * @param n giá trị khởi tạo cho tài nguyên
     */
    public ResourcesExploiterWithLock(int n) {
        // Gọi constructor của lớp cha
        super(n);
        // Khởi tạo ReentrantLock
        lock = new ReentrantLock();
    }
    
    /**
     * Phương thức exploit() được override với ReentrantLock
     * Sử dụng tryLock với timeout để tránh deadlock
     */
    @Override
    public void exploit() {
        try {
            // Cố gắng acquire lock trong vòng 10 giây
            if (lock.tryLock(10, TimeUnit.SECONDS)) {
                // Critical section - chỉ một thread được vào
                setRsc(getRsc() + 1);
            } else {
                // Không thể acquire lock trong 10 giây
                System.err.println("Warning: Could not acquire lock within 10 seconds");
            }
        } catch (InterruptedException e) {
            // Thread bị interrupt trong khi đợi lock
            e.printStackTrace();
            Thread.currentThread().interrupt(); // Restore interrupt status
        } finally {
            // Luôn luôn release lock trong finally block
            // Chỉ unlock nếu thread hiện tại đang hold lock
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
    
    /**
     * Phương thức để kiểm tra trạng thái lock (for debugging)
     */
    public boolean isLocked() {
        return lock.isLocked();
    }
    
    /**
     * Phương thức để lấy số thread đang đợi lock (for debugging)
     */
    public int getQueueLength() {
        return lock.getQueueLength();
    }
}